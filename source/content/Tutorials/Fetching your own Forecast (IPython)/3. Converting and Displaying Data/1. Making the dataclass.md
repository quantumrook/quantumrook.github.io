---
title: 1. Making the `ForecastData` dataclass
created: 03, Jan, 2025
modified:
  - 05, Jan, 2025
  - 03, Jan, 2025
---
Sooner or later, in programming, you'll get to the point where you're trying to keep so much information linked together about a specific instance that it becomes difficult to keep it all in sync. Dictionaries can help with that, and the current implementation of the forecast being a dictionary of dictionaries works - but there will inevitably be a breaking point:

- Either the mental model to keep track of where you are becomes too cumbersome
- or you need to start adding functionality alongside the data

In this case, neither might be true for you, but I think this is a great example of when introducing an object to hold the relevant information is helpful (and more importantly, not as contrived as some examples you'll see out on the wider web).

---

One of the ways we might want to restructure the data is to group the information from the extended forecast with the hourly.

```
Extend Forecast
	- has a detailed summary for a 12 hour period
	- high and low temperature ranges

Hourly Forecast
	- Projected temperature
	- Chance of Rain
	- Wind speed (which we can use to calculate windchill)
	- etc
```

Which we might want to combine to be something like:

```
YYYY-MM-DD's Forecast
	- summary of what the day is going to look like
	- summary of what the night is going to look like
	- the High and Low
	- Breakdown by hour
		- temperature (+ windchill)
		- Chance of Rain
		- Wind speed
```

And then we could access the information with the benefit of intellisense and preformatting the values in a desired format. Loosely translating this into a dictionary first would look something like:

```py
todays_forecast = {
	day_summary : "Text about how the daytime is going to look.",
	night_summary : "Text about how the evening is going to look.",
	temperature_high : 60,
	temperature_low : 30,
	hourly_breakdown : {
		"06" : {
			"temperature" : 45,
			"windchill" : 40,
			"chance_of_rain" : 30,
			"wind_speed": 6
		},
		# etc
	}
}
```

Or, with grouping more of the information together:

```py
todays_forecast = {
	summary : {
		day : "Text about how the daytime is going to look.",
		night : "Text about how the evening is going to look.",
	},
	temperature_range : {
		high : 60,
		low : 30
	},
	hourly_breakdown : {
		"06" : {
			"temperature" : 45,
			"windchill" : 40,
			"chance_of_rain" : 30,
			"wind_speed": 6
		},
		# etc
	}
}
```

While this does group the information from both forecasts together, the way we access it hasn't really changed: we end up needing to do chained dictionary key-value calls:

```py
print("Today's forecast:")
print(todays_forecast["summary"]["day"])
print(f"Hi: {todays_forecast["temperature_range"]["hi"]} Low: {todays_forecast["temperature_range"]["low"]}")

for hour, hourly_data in todays_forecast["hourly_breakdown"].items():
	if hour < 18:
		print(f"{hour}: {hourly_data["temperature"]} (Feels like: {hourly_data["windchill"]}) with a {hourly_data["chance_of_rain"]}% chance of rain and {hourly_data["wind_speed"]} mph winds.")

print("---")
# and then repeat for the evening
```

There's no explicit right or wrong way to do this, but the above implementation is very prone to errors in mistyping the key name or forgetting exactly how it's structured.

>[!example] 
>Take a good look at the implementation and then hide the window and see if you can remember how to access the temperature for 6 am by writing out.
>
>Did you remember all the keys you needed?
> > [!example]- Answer
> > `todays_forecast["hourly_breakdown"]["06"]["temperature"]`

So, what if we take our daily forecast structure and make a class out of it?

> One way you can think about what a `class` is: It is a concrete contract stating that all instances of it will contain specific properties (read: values/variables) and functionality.

```py
class DailyForecast(): # This tells python we are defining what the class is going to look like
	def __init__(self): # This function is called when we create a new instance of the class like: todays_forecast = DailyForecast().
		self.day_summary = ""
		self.night_summary = ""
		self.temperature_high = 0
		self.tempearture_low = 0
		self.hourly_breakdown = { }
```

What this does is state that each `instance` of `DailyForecast` is going to have the following properties on it:

- `day_summary`
- `night_summary`
- `temperature_high`
- `temperature_low`
- and a dictionary called `hourly_breakdown`

Before we worry about assigning values to these, this means we can start to restructure our code a bit:

```py
todays_forecast = DailyForecast()

print("Today's forecast:")
print(todays_forecast.day_summary)
print(f"Hi: {todays_forecast.temperature_high} Low: {todays_forecast.temperature_low}")
```

Now lets tackle initializing the `DailyForecast` with some data. When we create the new instance, we, in practice, already have the data accessible in the `extended_forecast` and `hourly_forecast` dictionaries, so it makes logical sense to initialize the new instance of `DailyForecast` with this information.

There are a few approaches to this:

- pass along the information using *positional arguments*
- pass along the information using *keyword arguments*
- pass along the dictionaries along with the date for the forecast and handle pulling the information out inside `__init__()`


Alternatively, we could create a function inside `DailyForecast` called something like `build()` that would be responsible for updating the values from their defaults to the corresponding data. This approach is more typically done when you don't have access to the data when you are creating the new instance.

Since we have the data, I'll opt for the three approaches above.

## Approach 1: Positional Arguments

What this means is that the names of the variables we use don't matter, but the order in which we put them inside `DailyForecast( ... )` does.

For example, I am going to structure `__init__` with the assumption that we will pass in the data in the order that we defined the variables inside the class:

```py
class DailyForecast(): # This tells python we are defining what the class is going to look like
	def __init__(self, day_summary, night_summary, temperature_high, temperature_low, hourly_breakdown): # This function is called when we create a new instance of the class like: todays_forecast = DailyForecast().
		self.day_summary = day_summary
		self.night_summary = night_summary
		self.temperature_high = temperature_high
		self.tempearture_low = tempearture_low
		self.hourly_breakdown = hourly_breakdown
```

Then, assuming we have already grabbed the information, we would construct our new instance like:

```py
todays_forecast = DailyForecast(day, night, high, low, hour_forecast)
```

>[!warning]
>If you're not careful with this approach, you can accidentally do something like:
>
>```py todays_forecast = DailyForecast(day, high, night, low, hour_forecast)```
>
>Which is subtle and you most likely won't find out until you try to do something with the values that isn't supported: like trying to do math to calculate the average temperature for the day (by averaging `hi` and `low`) and discover that you've accidentally been assigning the `night_summary` content into `temperature_high` instead.

Now this doesn't mean you should never take this approach, it is just something you should be aware of. The same thing can happen with the *by keyword* if you are not paying enough attention to what you are writing.

## Approach 2: Keyword Arguments

This approach is a bit more explicit in the assignment, as we specify the arguments name before placing the value. The structure of `__init__` remains unchanged, just how we call `DailyForecast`:

```py
todays_forecast = DailyForecast(day_summary=day, night_summary=night, temperature_high=high, temperature_low=low, hourly_breakdown=hour_forecast)
```

Personally, this is the approach I use all over the place, as it forces me to take the extra step to think about what is going where and helps create self documentation on what my thought process was/assumptions were.

## Approaches 1 & 2: Getting the Data

Ultimately, either way we go, we still need to iterate over both `hourly_data` and `extended_data to populate our `DailyForecast` with information. Starting with the `hourly_forecast` we can create our `hourly_breakdown` dictionary:

```py
todays_hourly_breakdown = { }

high = -273
low = 273

for period in hourly_data["properties"]["periods"]:
    period_date, period_time = period["startTime"].split("T")

    if period_date != today:
        break

    hour, *extra = period_time.split(":")
    speed, unit = period["windSpeed"].split(" ")

    todays_hourly_breakdown[hour] = {
        "temperature" : period["temperature"],
        "windchill" : 0, #We'll get to calculating this later
        "chance_of_rain" : period["probabilityOfPrecipitation"]["value"],
        "wind_speed": speed
    }

    if period["temperature"] > high:
        high = period["temperature"]

    if period["temperature"] < low:
        low = period["temperature"]
```

For clarity, I've opted to do this in a new cell, preserving what we did in the past. I have also introduced two variables to capture the highest and lowest temperatures for the day. Next we just need to grab the summary for the two twelve hour periods from `extended_data`. If you recall, the extended forecast gave us the `.json` structured like:

```json
{
    "@context": [ "..."],
    "type": "Feature",
    "geometry": {
        "type": "Polygon",
        "coordinates": [ "..." ]
    },
    "properties": {
        "..." : "...",
        "periods": [
            {
                "number": 1,
                "name": "Today",
                "startTime": "2025-01-05T10:00:00-07:00",
                "endTime": "2025-01-05T18:00:00-07:00",
                "isDaytime": true,
                "temperature": 28,
                "temperatureUnit": "F",
                "temperatureTrend": "",
                "probabilityOfPrecipitation": {
                    "unitCode": "wmoUnit:percent",
                    "value": null
                },
                "windSpeed": "6 mph",
                "windDirection": "ESE",
                "icon": "https://api.weather.gov/icons/land/day/sct?size=medium",
                "shortForecast": "Mostly Sunny",
                "detailedForecast": "Mostly sunny. High near 28, with temperatures falling to around 26 in the afternoon. East southeast wind around 6 mph."
            },
```

which we grab by:

```py
extended_data = forecast_response[0]

day_summary = ""
night_summary = ""

for period in extended_data["properties"]["periods"]:
    period_date, period_time = period["startTime"].split("T")

    if period_date != today:
        break
    
    hour, *extra = period_time.split(":")
    if int(hour) <= 12:
	    day_summary = period["detailedForecast"]
	else:
	    night_summary = period["detailedForecast"]
```

Then, we can pass everything into the constructor to build our new instance:

```py
todays_forecast = DailyForecast(
	day_summary=day_summary,
	night_summary=night_summary,
	temperature_high=high,
	temperature_low=low,
	hourly_breakdown=todays_hourly_breakdown
)
```

And finally format some output:

```py
print("Today's Forecast")
print(f"High: {todays_forecast.temperature_high}, Low: {todays_forecast.temperature_low}\n")

print(f"Today:")
print(f"\t{todays_forecast.day_summary}")

for hour, hourly_data in todays_forecast.hourly_breakdown.items():
    if int(hour) < 18 and int(hour) > 6:
        print(f"{hour}: {hourly_data["temperature"]}\N{DEGREE SIGN}F with {hourly_data["chance_of_rain"]}% chance of rain.")

print(f"\nThis Evening:")
print(f"\t{todays_forecast.night_summary}")

for hour, hourly_data in todays_forecast.hourly_breakdown.items():
    if int(hour) >= 18:
        print(f"{hour}: {hourly_data["temperature"]}\N{DEGREE SIGN}F with {hourly_data["chance_of_rain"]}% chance of rain.")
```

>[!note]
>The key of `hour` is stored as a string (or text), which means we need to first convert it to a numerical type before we can compare it, like in:
>
>`if int(hour) < 18 and int(hour) > 6:`
>
>This reads as "convert hour to an integer, then check if it is less than 18 and bigger than 6".

Which gives us the following output:

```
Today's Forecast
High: 53, Low: 49

Today:
	Rain likely. Mostly cloudy, with a high near 53. Southeast wind around 5 mph. Chance of precipitation is 60%. New rainfall amounts between a tenth and quarter of an inch possible.
11: 51°F with 16% chance of rain.
12: 51°F with 17% chance of rain.
13: 52°F with 22% chance of rain.
14: 52°F with 33% chance of rain.
15: 53°F with 58% chance of rain.
16: 51°F with 32% chance of rain.
17: 52°F with 43% chance of rain.

This Evening:
	Rain before 4am, then a slight chance of rain showers. Cloudy. Low around 44, with temperatures rising to around 46 overnight. East wind around 6 mph. Chance of precipitation is 80%. New rainfall amounts between a quarter and half of an inch possible.
18: 51°F with 64% chance of rain.
19: 50°F with 79% chance of rain.
20: 50°F with 80% chance of rain.
21: 49°F with 75% chance of rain.
22: 49°F with 55% chance of rain.
23: 49°F with 54% chance of rain.
```

>[!note]
>There's (technically) missing data in my example output, because at the time of writing, it was 10 am, and the `hourly_data` returned doesn't contain the hourly forecast for the previous hours.

### Wrap up

You should have four new cells at the end of your notebook:

Cell 5: Optional, just a separator between the first part of the tutorial
```markdown
## Using Classes
```

Cell 6: The class definition
```py
class DailyForecast():

    def __init__(self, day_summary, night_summary, high, low, hourly_breakdown):
        self.day_summary = day_summary
        self.night_summary = night_summary
        self.temperature_high = high
        self.temperature_low = low
        self.hourly_breakdown = hourly_breakdown
```

Cell 7: Getting the data and constructing our instance `todays_forecast` of `DailyForecast`
```py
todays_hourly_breakdown = { }

high = -273
low = 273

for period in hourly_data["properties"]["periods"]:
    period_date, period_time = period["startTime"].split("T")

    if period_date != today:
        break

    hour, *extra = period_time.split(":")
    speed, unit = period["windSpeed"].split(" ")

    todays_hourly_breakdown[hour] = {
        "temperature" : period["temperature"],
        "windchill" : 0, #We'll get to calculating this later
        "chance_of_rain" : period["probabilityOfPrecipitation"]["value"],
        "wind_speed": speed
    }

    if period["temperature"] > high:
        high = period["temperature"]

    if period["temperature"] < low:
        low = period["temperature"]

extended_data = forecast_response[0]

day_summary = ""
night_summary = ""

for period in extended_data["properties"]["periods"]:
    period_date, period_time = period["startTime"].split("T")

    if period_date != today:
        break

    hour, *extra = period_time.split(":")
    if int(hour) < 18:
        day_summary = period["detailedForecast"]
    else:
        night_summary = period["detailedForecast"]

todays_forecast = DailyForecast(
    day_summary=day_summary,
    night_summary=night_summary,
    high=high,
    low=low,
    hourly_breakdown=todays_hourly_breakdown
)
```

And Cell 8: Which prints out the forecast using our new class
```py
print("Today's Forecast")
print(f"High: {todays_forecast.temperature_high}, Low: {todays_forecast.temperature_low}\n")

print(f"Today:")
print(f"\t{todays_forecast.day_summary}")

for hour, hourly_data in todays_forecast.hourly_breakdown.items():
    if int(hour) < 18 and int(hour) > 6:
        print(f"{hour}: {hourly_data["temperature"]}\N{DEGREE SIGN}F with {hourly_data["chance_of_rain"]}% chance of rain.")

print(f"\nThis Evening:")
print(f"\t{todays_forecast.night_summary}")

for hour, hourly_data in todays_forecast.hourly_breakdown.items():
    if int(hour) >= 18:
        print(f"{hour}: {hourly_data["temperature"]}\N{DEGREE SIGN}F with {hourly_data["chance_of_rain"]}% chance of rain.")
```

![[{ECCB62F3-F35B-433A-BD4D-1EEAC9E69139}.png]]

## Approach 3: Passing in the dictionaries of data

In effect, this is either a mixture of the first or second approach, depending on how you construct call `DailyForecast`. It is just becomes a tradeoff of "simpler call signature" versus "more complexity in `__init__`".

```py
todays_forecast = DailyForecast(date, extended_data, hourly_data)
# or
todays_forecast = DailyForecast(date_of_forecast=date, extended_forecast=extended_data, hourly_forecast=hourly_data)
```

In effect, we essentially copy the code we wrote in Cell 7 (above) and reduce the need for intermediate variables. This is most likely surpasses the kind of complexity you would want inside the `__init__` function, and realistically would break up bits into logical chunks and create the corresponding functions.

```py
class DailyForecast():
    def __init__(self, date_of_forecast, extended_forecast, hourly_forecast):

        self.day_summary = ""
        self.night_summary = ""
        self.temperature_high = -273
        self.temperature_low = 273
        self.hourly_breakdown = { }

        for period in extended_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != date_of_forecast:
                break

            hour, *extra = period_time.split(":")
            if int(hour) < 18:
                self.day_summary = period["detailedForecast"]
            else:
                self.night_summary = period["detailedForecast"]

        for period in hourly_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != date_of_forecast:
                break

            hour, *extra = period_time.split(":")
            speed, unit = period["windSpeed"].split(" ")

            self.hourly_breakdown[hour] = {
                "temperature" : period["temperature"],
                "windchill" : 0, #We'll get to calculating this later
                "chance_of_rain" : period["probabilityOfPrecipitation"]["value"],
                "wind_speed": speed
            }

            if period["temperature"] > high:
                self.temperature_high = period["temperature"]
            if period["temperature"] < low:
                self.temperature_low = period["temperature"]
```

Since the logic is already chunked by the type of data we are passing in, we can use that as our guide for chunking it off:

```py
class DailyForecast():

    def __init__(self, date_of_forecast, extended_forecast, hourly_forecast):

        #Initialize our variables
        self.day_summary = ""
        self.night_summary = ""
        self.temperature_high = -273
        self.temperature_low = 273
        self.hourly_breakdown = { }

        #Populate our day and night summaries using the extended forecast data
        self.__get_summaries_from_data(
            date_of_forecast=date_of_forecast,
            extended_forecast=extended_forecast
        )

        #Create our hourly breakdown and record the highest and lowest temperatures
        self.__build_hourly_breakdown(
            date_of_forecast=date_of_forecast,
            hourly_forecast=hourly_forecast
        )

    def __get_summaries_from_data(self, date_of_forecast, extended_forecast):

        for period in extended_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != date_of_forecast:
                break

            hour, *extra = period_time.split(":")
            if int(hour) < 18:
                self.day_summary = period["detailedForecast"]
            else:
                self.night_summary = period["detailedForecast"]

    def __build_hourly_breakdown(self, date_of_forecast, hourly_forecast):

        for period in hourly_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != date_of_forecast:
                break

            hour, *extra = period_time.split(":")
            speed, unit = period["windSpeed"].split(" ")

            self.hourly_breakdown[hour] = {
                "temperature" : period["temperature"],
                "windchill" : 0, #We'll get to calculating this later
                "chance_of_rain" : period["probabilityOfPrecipitation"]["value"],
                "wind_speed": speed
            }

            if period["temperature"] > high:
                self.temperature_high = period["temperature"]
            if period["temperature"] < low:
                self.temperature_low = period["temperature"]
```

>[!note]
>The use of `__` as a prefix to each function name is to signal to other users of this class (potentially yourself later on) that the function is intended to be used internally. As in, "Hey, you shouldn't ever be calling this outside of the class itself, and if you are, you might break things. Ye have been warned."

Generally speaking, you want to write self descriptive code that creates a narrative as you read it. `self.__get_summaries_from_data()` does this fairly well for setting the context of what you are going to do. Nitpicking my own writing:

- I would recommend probably changing the name to `__set_summaries_from_data`, as `get` typically means that the function is going to return a value.
- `__build_hourly_breakdown()` could probably be named better, as it does not give any clue that we are also setting the values of `temperature_high` and `temperature_low` inside of it. This is only hinted at because of the comment above the function call inside `__init__`. 
	- We could instead be explicit and rename it to `__build_hourly_breakdown_and_set_high_and_low`, which I'd normally advocate for being self-descriptive as it doesn't cost us anything to write a longer function name. However, there does eventually become a tradeoff in legibility as these things get longer.
	- One alternative is to brainstorm a better name that is more concise, which can be tricky (and sometimes time consuming).
	- Another alternative is to make setting the extreme temperatures its own function. In **this** use case, iterating over the data isn't too expensive (in terms of time and compute power), but for bigger data sets, you might sacrifice some explicit clarity for performance.

To give you an idea of what the separate function looks like, I would probably do the following:

```py
	def __record_temperature_extremes(self, date_of_forecast, hourly_forecast):
		for period in hourly_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != date_of_forecast:
                break

			if period["temperature"] > high:
                self.temperature_high = period["temperature"]
            if period["temperature"] < low:
                self.temperature_low = period["temperature"]
```

>[!note]
>One of the things that you'll discover in processes like this is that there ends up being a common parameter you pass around, and in this case it is `date_of_forecast`. Thinking about it, that would probably be a nice thing to be able to reference later on.
>
>The natural extension of making this class is not to just hold today's forecast, but to also convert the rest of the forecast data into instances of `DailyForecast`, and if we have a list of these instances - it would be very helpful to know which day the forecast is for.
>
>So, with that being said, I will also add a `date` property to the class inside `__init__` as shown in the class description below. And since it is an instance variable now, the function signatures can change to omit passing this parameter along and just reference the value instead.


such that the class now looks like:

```py
class DailyForecast():

    def __init__(self, date_of_forecast, extended_forecast, hourly_forecast):

        #Initialize our variables
        self.date = date_of_forecast
        self.day_summary = ""
        self.night_summary = ""
        self.temperature_high = -273
        self.temperature_low = 273
        self.hourly_breakdown = { }

        #Populate our day and night summaries using the extended forecast data
        self.__set_summaries_from_data(
            extended_forecast=extended_forecast
        )

         #Create our hourly breakdown
        self.__build_hourly_breakdown(
            hourly_forecast=hourly_forecast
        )

        #Record the highest and lowest temperatures
        self.__record_temperature_extremes(
            hourly_forecast=hourly_forecast
        )

    def __set_summaries_from_data(self, extended_forecast):

        for period in extended_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != self.date:
                break

            hour, *extra = period_time.split(":")
            if int(hour) < 18:
                self.day_summary = period["detailedForecast"]
            else:
                self.night_summary = period["detailedForecast"]

    def __build_hourly_breakdown(self, hourly_forecast):

        for period in hourly_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != self.date:
                break

            hour, *extra = period_time.split(":")
            speed, unit = period["windSpeed"].split(" ")

            self.hourly_breakdown[hour] = {
                "temperature" : period["temperature"],
                "windchill" : 0, #We'll get to calculating this later
                "chance_of_rain" : period["probabilityOfPrecipitation"]["value"],
                "wind_speed": speed
            }

    def __record_temperature_extremes(self, hourly_forecast):

        for period in hourly_forecast["properties"]["periods"]:
            period_date, period_time = period["startTime"].split("T")

            if period_date != self.date:
                break

            if period["temperature"] > high:
                self.temperature_high = period["temperature"]
            if period["temperature"] < low:
                self.temperature_low = period["temperature"]
```

