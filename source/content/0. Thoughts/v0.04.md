---
title: v0.04
created: 11, Jan, 2025
modified:
  - 12, Jan, 2025
  - 11, Jan, 2025
---
List of outstanding work items:

- Handle escaped characters in pre-formatted blocks (code blocks)
	- probably need to skip over these in some of the formatting to avoid any false positives
- Embedding other notes
- Math support (most likely just using MathJax for the time being)

## Coffee Thoughts

Today's goal is to tackle the embedding of other notes, which is going to require some fundamental changes.

In theory, the *simplest(?)* way would be to somehow feed a list of markdown files to `md_to_html.py` in a sorted order: files that have no dependency go first, then the files that depended on them, and we're golden.

Assuming that `md_to_html.py` is provided this queue (regardless of how its constructed just yet) would mean that when it comes across an internal embed `![[ ]]`, we then need to go to the generated html file and snag everything between `<section>` tags.

This means the flow is something like:

1. Generate queue, sorted by no dependency (start) to dependencies (end)
2. Do the current process of conversion, including generating the `.html` file.
3. When an internal embed is found:
	1. Open up the matching `.html` file
	2. Find the `<section>` tags associated with the anchor
	3. copy that content
	4. splice that content into the file with the embed, replacing `![[ ]]` with `<section> {{content}} </section>`
	5. Continue as normal
4. Continue until the queue is empty

### Alternative

Since I already have the `{{ placeholder }}` syntax in use, I could replace `![[v0.03#Coffee Thoughts]]` with `{{ file: "v0.03.md" anchor: "Coffee-Thoughts" }}` and continue as normal.

Then before the script finishes, it does a pass on each generated `html` file searching for any remaining `{{ placeholder }}` and if it finds it, go search for the corresponding file and copy-paste.

The benefit here is that we don't have to worry about the order of markdown files being consumed by the script, but we do lose by having to re-read each file. This naturally then screams that some sort of flag should be triggered when it discovers the presence of the embed link, or just that the file name is added to a list, e.g.:

```python
if markdown_file.has_embed():
	files_with_embed.append(markdown_file)
```

I'm really fighting the desire to make a markdown file object: my gut says to do it because the complexity is growing beyond just passing around a `list[str]` but I don't know if I've actually reached the point where it would help. I mean, it might make some of the code a bit more clear?

### Considering a Markdown Class

```python
class MarkdownFile():
	def __init__(self, filename, filecontents):
		self.file_name = filename

		self.frontmatter = self.__splice_frontmatter(filecontents)
		self.body = self.__splice_body(filecontents)
```

I could actually have the class responsible for reading in the file contents from the `.md` and then instead of doing `file.readlines()`, I could read line by line and:

- splice the frontmatter in place
- append to the body as we go
- check for embeds while appending

Which would save me the extra cost of reading to find out if the file in question has any embeds. Of course, I could also just change the current file reading function to do the same thing right now, without the class.

### Super crazy thought

What if I converted the markdown into JSON first? What would that even look like?

I guess I'm just thinking more like a key-value pair for content blocks

```python
markdown_body = 
{
	"## This is H2" :
		{
			"content" : 
			[
				"Here's **some text**.\n",
				"\n",
				"I should **probably** get *some* ***lorem-ipsum*** in here.\n",
				"\n",
				"~~TODO: add lorem-ipsum~~\n",
				"Here's an [internal link](#this-is-h2) to the same file. And here's an [internal site](/Example2.md) link. Here's a [link](/Example2.md#other-h2) to a header in the other file.\n",
				"Now for the tricky part (?) let's link to the formatting [sheet](https://help.obsidian.md/Editing+and+formatting/Basic+formatting+syntax). And now an external image: ![Engelbart](https://history-computer.com/ModernComputer/Basis/images/Engelbart.jpg)\n"
			],
			"### Lorem Ipsum" :
			{
				"> [!note]" : "> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras ullamcorper eros at maximus porta. Vestibulum lectus metus, ornare nec suscipit at, sagittis vitae augue. Vestibulum sem velit, lobortis eu mattis nec, pulvinar ac metus. Nulla ex quam, gravida in efficitur vel, accumsan vitae lorem. In at malesuada mauris. Etiam id dui sit amet nisl efficitur fermentum. Nam mattis sapien eget dolor imperdiet suscipit. Phasellus tristique eleifend dolor nec ultrices. Fusce semper ex mollis risus vehicula fringilla. Vivamus commodo ut tortor vitae ultricies. Mauris consequat fermentum egestas. Nunc pulvinar mauris ipsum, a ornare massa consectetur eget.",
				#etc
			},
		},	 
}
```

I mean... it could be interesting, because then everything is already sectioned off, which would simplify the conversion functions -- since they would no longer have to do special logic for tracking if a block has started and where it ends.

The problem becomes: How do you know how far down to dig in this dictionary structure?

I guess at its extreme (not that I'll every use them), the deepest header level is 6: `######`, and then at that point you can figure out how deep you could nest things. I know there's a page on here that has a table inside a callout.

You can also nest callouts in callouts, but I don't know how deep you can go with that. I know I have at least one instance of a nested callout,

> > >3
> > > >4
> > > > >5
> > > > > >6
> > > > > > >7
> > > > > > > >8
> > > > > > > > >9
> > > > > > > > > >10
> > > > > > > > > > >11
> > > > > > > > > > > >12
> > > > > > > > > > > > >13
> > > > > > > > > > > > > >14
> > > > > > > > > > > > > > >15
> > > > > > > > > > > > > > > >16
> > > > > > > > > > > > > > > > >17
> > > > > > > > > > > > > > > > > >18
> > > > > > > > > > > > > > > > > > >19
> > > > > > > > > > > > > > > > > > > >20
> > > > > > > > > > > > > > > > > > > > > 21

Okay that's pretty insane that Obsidian apparently just allows infinite nesting of callouts. I think for sanity reasons I could probably cap it at 5, because at some point it just loses meaning and you probably should reevaluate how you're structuring your content on the page. The good news in this situation, is that Obsidian doesn't support headers in callouts, because that'd effectively start the whole process over again.

Of course the trick here is to come up with the logical and consistent way to structure the key-value pairs, but this is rather tempting... Especially when it comes to dealing with the embedded content, as I could just splice in the content super easily.