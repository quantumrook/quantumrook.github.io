---
title: v0.04
created: 11, Jan, 2025
modified:
  - 15, Jan, 2025
  - 14, Jan, 2025
  - 13, Jan, 2025
  - 12, Jan, 2025
  - 11, Jan, 2025
---
List of outstanding work items:

- Handle escaped characters in pre-formatted blocks (code blocks)
	- probably need to skip over these in some of the formatting to avoid any false positives
- Embedding other notes
- Math support (most likely just using MathJax for the time being)

## Coffee Thoughts

Today's goal is to tackle the embedding of other notes, which is going to require some fundamental changes.

In theory, the *simplest(?)* way would be to somehow feed a list of markdown files to `md_to_html.py` in a sorted order: files that have no dependency go first, then the files that depended on them, and we're golden.

Assuming that `md_to_html.py` is provided this queue (regardless of how its constructed just yet) would mean that when it comes across an internal embed `![[ ]]`, we then need to go to the generated html file and snag everything between `<section>` tags.

This means the flow is something like:

1. Generate queue, sorted by no dependency (start) to dependencies (end)
2. Do the current process of conversion, including generating the `.html` file.
3. When an internal embed is found:
	1. Open up the matching `.html` file
	2. Find the `<section>` tags associated with the anchor
	3. copy that content
	4. splice that content into the file with the embed, replacing `![[ ]]` with `<section> {{content}} </section>`
	5. Continue as normal
4. Continue until the queue is empty

### Alternative

Since I already have the `{{ placeholder }}` syntax in use, I could replace `![[v0.03#Coffee Thoughts]]` with `{{ file: "v0.03.md" anchor: "Coffee-Thoughts" }}` and continue as normal.

Then before the script finishes, it does a pass on each generated `html` file searching for any remaining `{{ placeholder }}` and if it finds it, go search for the corresponding file and copy-paste.

The benefit here is that we don't have to worry about the order of markdown files being consumed by the script, but we do lose by having to re-read each file. This naturally then screams that some sort of flag should be triggered when it discovers the presence of the embed link, or just that the file name is added to a list, e.g.:

```python
if markdown_file.has_embed():
	files_with_embed.append(markdown_file)
```

I'm really fighting the desire to make a markdown file object: my gut says to do it because the complexity is growing beyond just passing around a `list[str]` but I don't know if I've actually reached the point where it would help. I mean, it might make some of the code a bit more clear?

### Considering a Markdown Class

```python
class MarkdownFile():
	def __init__(self, filename, filecontents):
		self.file_name = filename

		self.frontmatter = self.__splice_frontmatter(filecontents)
		self.body = self.__splice_body(filecontents)
```

I could actually have the class responsible for reading in the file contents from the `.md` and then instead of doing `file.readlines()`, I could read line by line and:

- splice the frontmatter in place
- append to the body as we go
- check for embeds while appending

Which would save me the extra cost of reading to find out if the file in question has any embeds. Of course, I could also just change the current file reading function to do the same thing right now, without the class.

### Super crazy thought

What if I converted the markdown into JSON first? What would that even look like?

I guess I'm just thinking more like a key-value pair for content blocks

```python
markdown_body = 
{
	"## This is H2" :
		{
			"content" : 
			[
				"Here's **some text**.\n",
				"\n",
				"I should **probably** get *some* ***lorem-ipsum*** in here.\n",
				"\n",
				"~~TODO: add lorem-ipsum~~\n",
				"Here's an [internal link](#this-is-h2) to the same file. And here's an [internal site](/Example2.md) link. Here's a [link](/Example2.md#other-h2) to a header in the other file.\n",
				"Now for the tricky part (?) let's link to the formatting [sheet](https://help.obsidian.md/Editing+and+formatting/Basic+formatting+syntax). And now an external image: ![Engelbart](https://history-computer.com/ModernComputer/Basis/images/Engelbart.jpg)\n"
			],
			"### Lorem Ipsum" :
			{
				"> [!note]" : "> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras ullamcorper eros at maximus porta. Vestibulum lectus metus, ornare nec suscipit at, sagittis vitae augue. Vestibulum sem velit, lobortis eu mattis nec, pulvinar ac metus. Nulla ex quam, gravida in efficitur vel, accumsan vitae lorem. In at malesuada mauris. Etiam id dui sit amet nisl efficitur fermentum. Nam mattis sapien eget dolor imperdiet suscipit. Phasellus tristique eleifend dolor nec ultrices. Fusce semper ex mollis risus vehicula fringilla. Vivamus commodo ut tortor vitae ultricies. Mauris consequat fermentum egestas. Nunc pulvinar mauris ipsum, a ornare massa consectetur eget.",
				#etc
			},
		},	 
}
```

I mean... it could be interesting, because then everything is already sectioned off, which would simplify the conversion functions -- since they would no longer have to do special logic for tracking if a block has started and where it ends.

The problem becomes: How do you know how far down to dig in this dictionary structure?

I guess at its extreme (not that I'll every use them), the deepest header level is 6: `######`, and then at that point you can figure out how deep you could nest things. I know there's a page on here that has a table inside a callout.

You can also nest callouts in callouts, but I don't know how deep you can go with that. I know I have at least one instance of a nested callout,

> > >3
> > > >4
> > > > >5
> > > > > >6
> > > > > > >7
> > > > > > > >8
> > > > > > > > >9
> > > > > > > > > >10
> > > > > > > > > > >11
> > > > > > > > > > > >12
> > > > > > > > > > > > >13
> > > > > > > > > > > > > >14
> > > > > > > > > > > > > > >15
> > > > > > > > > > > > > > > >16
> > > > > > > > > > > > > > > > >17
> > > > > > > > > > > > > > > > > >18
> > > > > > > > > > > > > > > > > > >19
> > > > > > > > > > > > > > > > > > > >20
> > > > > > > > > > > > > > > > > > > > > 21

Okay that's pretty insane that Obsidian apparently just allows infinite nesting of callouts. I think for sanity reasons I could probably cap it at 5, because at some point it just loses meaning and you probably should reevaluate how you're structuring your content on the page. The good news in this situation, is that Obsidian doesn't support headers in callouts, because that'd effectively start the whole process over again.

Of course the trick here is to come up with the logical and consistent way to structure the key-value pairs, but this is rather tempting... Especially when it comes to dealing with the embedded content, as I could just splice in the content super easily.

## The Nested Dictionary Approach: Post Mortem

The complexity of this probably should have been a bigger warning sign. Its even difficult to figure out where to start in explaining what I've done for the past couple days.

### Chunking content

So, the core idea was to create a structure where the key was the start of a *block* and the value was the corresponding *block*, e.g.

```python
def nest_subheadings_inside_headings(grouped_by_headers):
    headers = ['######', '#####', '####', '###', '##']
    headers.reverse()

    by_h2 = { }
    last_header = { }

    for header_key in list(grouped_by_headers.keys()):
        cleaned_key = header_key.split(" ")[0]
        last_header[cleaned_key] = header_key

        match cleaned_key:
            case "##":
                by_h2[header_key] = {"content" : grouped_by_headers[header_key]}
            case "###":
                by_h2[last_header["##"]][header_key] = {"content" : grouped_by_headers[header_key]}
            case "####":
                by_h2[last_header["##"]][last_header["###"]][header_key] = {"content" : grouped_by_headers[header_key]}
            case "#####":
                by_h2[last_header["##"]][last_header["###"]][last_header["####"]][header_key] = {"content" : grouped_by_headers[header_key]}
            case _:
                by_h2[last_header["##"]][last_header["###"]][last_header["####"]][last_header["#####"]][header_key] = {"content" : grouped_by_headers[header_key]}

    return by_h2
```

So, something like this snippet from `example.md`:

```markdown
## Table of Features Implemented

| Feature | Implemented |
| ------- | ----------- |
| Unordered Lists | Yes |
| Ordered Lists | Yes |
| Task Lists | Yes |
| images, internal | Yes |
| images, external | Yes |
| links, internal | Yes |
| links, external | Yes |
| links, embedded | No |
| Tables | Yes |
| Callouts | Yes |
| Code Blocks | Yes |
| Math | No |

![small banner](/content/small_banner.png)

## This is H2

Here's **some text**.

I should **probably** get *some* ***lorem-ipsum*** in here.

~~TODO: add lorem-ipsum~~

Here's an [internal link](#this-is-h2) to the same file. And here's an [internal site](/Example2.md) link. Here's a [link](/Example2.md#other-h2) to a header in the other file.

Now for the tricky part (?) let's link to the formatting [sheet](https://help.obsidian.md/Editing+and+formatting/Basic+formatting+syntax). And now an external image: ![Engelbart](https://history-computer.com/ModernComputer/Basis/images/Engelbart.jpg)

### Lorem Ipsum

> [!note]
> `~snip~`
```

would ultimately be parsed into the following dictionary:

```python
example_by_h2 = 
{
	"## Table of Features Implemented" : 
	{
		"content" : 
		[
			['| Feature | Implemented |', '| ------- | ----------- |', '| Unordered Lists | Yes |', '| Ordered Lists | Yes |', '| Task Lists | Yes |', '| images, internal | Yes |', '| images, external | Yes |', '| links, internal | Yes |', '| links, external | Yes |', '| links, embedded | No |', '| Tables | Yes |', '| Callouts | Yes |', '| Code Blocks | Yes |', '| Math | No |'],
			['![small banner](/content/small_banner.png)']
		]
	},
	"## This is H2" : 
	{
		"content" :
		[
			["Here's **some text**."],
			['I should **probably** get *some* ***lorem-ipsum*** in here.'],
		    ['~~TODO: add lorem-ipsum~~'],
		    ["Here's an [internal link](#this-is-h2) to the same file. And here's an [internal site](/Example2.md) link. Here's a [link](/Example2.md#other-h2) to a header in the other file."],
		    ["Now for the tricky part (?) let's link to the formatting [sheet](https://help.obsidian.md/Editing+and+formatting/Basic+formatting+syntax). And now an external image: ![Engelbart](https://history-computer.com/ModernComputer/Basis/images/Engelbart.jpg)"],
		],
		"### Lorem Ipsum" :
		{
			"content" :
			[
				['> [!note] \n', '> `~snip`'],
			],
		},
	},
}
```

Part of the power for this approach, is that it drastically simplified the logic for having `<section>` tags wrap around each section. The other benefit was that each *block* of content was contained in its own list, and it all came about from the simple realization: every *block* was separated by a line containing only `\n`.

> There is one exception to this, which is the nestable elements, such as lists and callouts

But this was a huge leap forward: I no longer had to have special rules in each of the handler modules for looking to see if we've started a block, are in a block, or finished a block. Most of it could've been standardized, but there's a bunch of edge cases for each different type of syntax that was causing a bunch of friction whenever I tried.

### The Promise

Anyways, this was basically exactly what I wanted when it came to dealing with embedded links. All I had to do was find the header for the corresponding file and I could just splice that into the embedded file.

So, we have the file `embedded_example.md`, whose contents are:

```markdown
---
title: "Embedded Example"
created: "2025-01-11"
modified:
    - "2025-01-11"
---

## Content from Example

This is an example of embedded content:

![[example#Now onto some code]]
```

Which means we need to get the *block* of content, from `example.md`, that falls under the header of `Now onto some code`.

In this simple example, that *should* be as straight forward as taking the line `![[example#Now onto some code]]` and replacing it with the key-value pair from `example_by_h2`:

```python
embedded_example_h2 = 
{
	"## Content from Example" : 
	{
		"content" :
		[
			['This is an example of embedded content:\n'],
			['![[example#Now onto some code]]\n']
		]
	}	
}
```

becomes:

```python
embedded_example_h2 = 
{
	"## Content from Example" : 
	{
		"content" :
		[
			['This is an example of embedded content:\n'],
			[
				"## Now onto some code" :
				{
					"content" :
					[
						['Here, we create a simple loop in python:'],
					    ['```python', '# before: start, stop, step', 'for i in range(start, stop, step):', '    f.integrate(i)', '```'],
					    ["Now let's step through this:"],
					    ['```', 'define start', 'define stop', 'define our step size', 'do numerical integration', '```'],
					]
				} 
			]
		]
	}	
}
```

### The Problem

So, in theory, this works out great, and in practice -before implementing the embedded logic- it handled the markdown to html conversion great.

This is where warning 2 should've kicked things off:

```python
def format_content(nested_blocks_of_content):
    html_content = ""
    for h2, h2_content in nested_blocks_of_content.items():
        h2_prefix, h2_indent, h2_suffix = get_block_wrapper(h2)
        h2_block = ""
        for h3, h3_content in h2_content.items():
            if h3 == "content":
                h2_block += format_block(h2_indent, h3_content)
            else:
                h3_prefix, h3_indent, h3_suffix = get_block_wrapper(h3)
                h3_block = ""
                for h4, h4_content in h3_content.items():
                    if h4 == "content":
                        h3_block += format_block(h3_indent, h4_content)
                    else:
                        h4_prefix, h4_indent, h4_suffix = get_block_wrapper(h4)
                        h4_block = ""
                        for h5, h5_content in h4_content.items():
                            if h5 == "content":
                                h4_block += format_block(h4_indent, h5_content)
                            else:
                                h5_prefix, h5_indent, h5_suffix = get_block_wrapper(h5)
                                h5_block = ""
                                for h6, h6_content in h5_content.items():
                                    if h6 == "content":
                                        h5_block += format_block(h5_indent, h6_content)
                                    else:
                                        h6_prefix, h6_indent, h6_suffix = get_block_wrapper(h6)
                                        h6_block = ""
                                        for sub_h6, sub_h6_content in h6_content.items():
                                            h6_block += format_block(h6_indent, sub_h6_content)
                                        h5_block += h6_prefix + h6_block + h6_suffix
                                h4_block += h5_prefix + h5_block + h5_suffix
                        h3_block += h4_prefix + h4_block + h4_suffix
                h2_block += h3_prefix + h3_block + h3_suffix
        html_content += h2_prefix + h2_block + h2_suffix

    return html_content
```

Because I'm supporting an arbitrary amount of nested headers, I have no way of knowing what the structure of `nested_blocks_of_content` looks like. Which means I have to unwrap this whole thing in order to do the formatting.

If this were a one off thing, I could probably live with it, but if you scroll back up to what `embedded_example_h2` became... I was in the situation where I might have to do this whole nested looping *again* - while already in the process of doing it.

And... that's just too much.

There's also a few problems with this approach, while logical, it requires a strict hierarchy of headers.

So something like:

```markdown
%%frontmatter stuff%%
---

Hi, I occasionally like to put text before headers.

## Now let's get started

Blah.
```

would fail. Now I can fix this by personally always starting each document with an h2 as the first bit of non-frontmatter content, however, that doesn't help with:

```
%%frontmatter stuff%%
---

### Summary

Here's a quick summary of the content coming up in this document.

## Now let's get started

Blah.
```

There's no h2 for that h3 to be nested inside. Again, I could probably fake it such that there's a special exemption for the first block of content.. but we're growing in even more complexity for an already monstrous process.

One more hole to blow in the sinking ship: The Markdown spec doesn't require you logically(?) nest headers, e.g.

```markdown

## I'm an H2

#### But I'm and H4
```

And, I don't have a problem with that, but the nested dictionary would freak out.

```python
example_by_h2["## I'm an H2"][???]["#### But I'm and H4"]
```

Basically, I'd need to have a placeholder h3 (or whatever header level) key to handle this.. and.. yeah, let's just let the ship sink at this point.

## Coffee Thoughts, pt. 2

I think my requirements are still roughly the same in that

- I want to be able to chunk a markdown file by section
- I need to easily access a chunk for embedding
- I need something that respects the hierarchy of the document

So, 

- nested dictionaries are out.
- a markdown class:
	- most likely the same issue in supporting a non-strict hierarchy
- a tree?

It's been a minute since I've implemented a tree from scratch, so this requires more thinking before I get started, but I think the basic implementation will work:

- each node is a section
	- has the section name
	- has a branch for each child section
	- has its own content

I'm wondering if the parent should also know who its children are, so I can have a toplevel function that I can call when I'm searching for the relevant section to embed, instead of having to walk through the tree until I find it, and then remember the path.

And while I'm at it, I could probably have a flag property on the node, such that during construction (since I'm reading through everything): if we find an embedded link, set that flag to true.

Optionally, instead of it just being a boolean, I could have it save the file name and section name, so I don't have to rewalk when I'm going to handle embeds.

## The Tree Approach

Okay, so with all that in mind, let's get started. Now, the general implementation would have a lot of extra functionality that we can ultimately omit because we are only supporting a very specific use case and know how the data will be structured.

```python
  class MarkdownNode():

    def __init__(self, block_data, block_name):
        self.children = [ ]
        self.block_data = block_data
        self.block_name = block_name

    def get_branch_name(self):
        branch_names = [ ]
        if not self.children:
            return [self.block_name]
        for child in self.children:
            for child_name in child.get_branch_name():
                branch_names.append(f"{self.block_name} -> {child_name}")
        return branch_names


h2 = MarkdownNode("Lorem Ipsum would be over kill", "h2")
h3 = MarkdownNode("Here are two reasons why", "h3")
h2.children.append(h3)


h4a = MarkdownNode("Reason 1", "h4a")
h4b = MarkdownNode("Reason 2", "h4b")

h3.children.append(h4a)
h3.children.append(h4b)

print(h2.get_branch_name())
```

which gives the expected output of:

```python
['h2 -> h3 -> h4a', 'h2 -> h3 -> h4b']
```

The next thing that would be useful is probably a `collapse_branch()` function that does a similar thing to the `get_branch_name()`, but returns the content instead. 

Or...

I could start with a `get_content_for_branch(branch_name)`, and that looks something like:

```python
    def get_content_for_branch_name(self, branch_name):
        if branch_name == self.block_name:
            return self.block_data

        this_branch_names = self.get_branch_name()
        not_found = True

        for this_branch in this_branch_names:
            print(this_branch)
            if branch_name in this_branch:
                not_found = False

        if not_found:
            return ""

        for child in self.children:
            child_answer = child.get_content_for_branch_name(branch_name)
            if child_answer:
                return child_answer
```

which, testing with

```python
print(h2.get_content_for_branch_name("h4b"))
```

gives

```
h2 -> h3 -> h4a
h2 -> h3 -> h4b
h3 -> h4a
h3 -> h4b
h4a
Reason 2
```

Nice.

I should then be able to do a similar approach for setting content, which will make handling the embedding part a lot easier. 

```python
    def set_content_for_branch_name(self, branch_name, branch_data):
        if branch_name == self.block_name:
            self.block_data = branch_data

        this_branch_names = self.get_branch_name()
        not_found = True

        for this_branch in this_branch_names:
            if branch_name in this_branch:
                not_found = False

        if not_found:
            return ""

        for child in self.children:
            child.set_content_for_branch_name(branch_name, branch_data)
```

Yep, pretty much a copy-paste.

```python
print(h4a.block_data)
h2.set_content_for_branch_name("h4a", "I've been replaced!")
print(h4a.block_data)
```

Gives:

```
Reason 1
I've been replaced!
```

Now I think its time to hook up the example files and see what it looks like.... But that requires me to redo the *chopping of content blocks*.

### Setting up Tests

I've been procrastinating by reading various tech blogs, and one in particular was about [rqlite](https://philipotoole.com/how-is-rqlite-tested/). While the tech doesn't apply here, the write up on how the dev has maintained the codebase has triggered the thought:

I'm basically doing manual tests of my code base with these example files already... so why not formalize the process with unit tests?

I mean, in that sense, I'm already doing it, but I have to manually check the output versus expectations to make sure changes/fixes didn't break anything else... so why not actually benefit from a test suite?

My exposure to writing unit tests is rather limited, and I don't think I've done them in python before, so this might take a minute to get set up.

..

I might not have the best way for testing each case done correctly, but from what I can see, I now have coverage for:

- chopping the body into a tree of nodes 
	- with no frontmatter present
	- with frontmatter present
	- with multiple levels, some repeated (per the `nested_example.md` file)
	- with horizontal rules present (per the `no_frontmatter.md` file)

And that gives a lot more confidence for what comes next... ~~Revisiting embeddings~~

Just kidding, I still need to chunk content into blocks for things like preformatted text and callouts.